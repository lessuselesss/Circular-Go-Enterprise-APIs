This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
circular_protocol_api/
  account.go
  certificate.go
examples/
  basic_workflow/
    main.go
  signing_data/
    main.go
utils/
  helpers.go
.gitignore
go.mod
LICENSE
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="examples/basic_workflow/main.go">
package main

import (
	"fmt"
	"log"
	"strings" // Added for strings.HasPrefix

	"github.com/circular-protocol/circular-go/circular_protocol_api"
	"github.com/circular-protocol/circular-go/utils"
)

func main() {
	fmt.Println("Circular Go Enterprise API - Basic Workflow Example")
	fmt.Printf("Current UTC Timestamp: %s\n", utils.GetFormattedUTCTimestamp())

	// Replace with your actual address and private key
	const userAddress = "your-wallet-address-hex"
	// IMPORTANT: Never hardcode private keys in production code.
	// This is for demonstration purposes only. Use environment variables or a secure vault.
	const userPrivateKeyHex = "11842e4034999297038f59f054d1794389758469070e15999837078cec243f55" // Example valid-looking hex
	const blockchainID = "0x8a20baa40c45dc5055aeb26197c203e576ef389d9acb171bd62da11dc5ad72b2"    // Example blockchain ID

	account := &circular_protocol_api.Account{}

	// 1. Open Account
	account.Open(userAddress)
	fmt.Printf("Account opened for address: %s\n", account.Address)

	// 2. Set Network and Blockchain
	err := account.SetNetwork("testnet") // Or "mainnet"
	if err != nil {
		log.Fatalf("Failed to set network: %v", err)
	}
	account.SetBlockchain(blockchainID)
	fmt.Printf("Network: %s, NAG URL: %s\n", account.Network, account.NAGURL)
	fmt.Printf("Blockchain ID: %s\n", account.Blockchain)

	// 3. Update Account (Fetch Nonce)
	fmt.Println("Attempting to update account (fetch nonce)...")
	if err := account.UpdateAccount(); err != nil {
		log.Printf("Warning: Failed to update account (fetch nonce): %v. Using default Nonce: %d\n", err, account.Nonce)
	} else {
		fmt.Printf("Account Nonce updated to: %d\n", account.Nonce)
	}

	// 4. Prepare data and submit certificate
	certificateData := fmt.Sprintf("My important data for certification at %s", utils.GetFormattedUTCTimestamp())

	fmt.Printf("Submitting certificate with data: '%s'\n", certificateData)
	submitResp, err := account.SubmitCertificate(certificateData, userPrivateKeyHex)
	if err != nil {
		log.Printf("Failed to submit certificate (likely due to placeholder NAG): %v\n", err)
		if submitResp.Response.TxID == "" {
			submitResp.Response.TxID = "mockTxID_for_example_flow_due_to_error"
			fmt.Println("Using mock TxID for example flow as submission failed.")
		}
	}

	if submitResp.Result == 200 || (submitResp.Response.TxID != "" && !strings.HasPrefix(submitResp.Response.TxID, "mockTxID_")) {
		fmt.Printf("Certificate submission potentially successful or pending. Transaction ID: %s\n", submitResp.Response.TxID)
	} else if submitResp.Response.TxID != "" && strings.HasPrefix(submitResp.Response.TxID, "mockTxID_") {
		fmt.Printf("Certificate submission was mocked. Transaction ID: %s\n", submitResp.Response.TxID)
	} else {
		fmt.Printf("Certificate submission failed. Result: %d, Message: %s\n", submitResp.Result, submitResp.Message)
		if submitResp.Response.TxID == "" {
			submitResp.Response.TxID = "mockTxID_for_failed_submission"
			fmt.Println("Using mock TxID for further example steps after submission failure.")
		}
	}

	if submitResp.Response.TxID != "" {
		txID := submitResp.Response.TxID

		// 5. Get Transaction Outcome
		fmt.Printf("Polling for transaction outcome for TxID: %s...\n", txID)
		outcomeResp, err := account.GetTransactionOutcome(txID, 15)
		if err != nil {
			log.Printf("Failed to get transaction outcome (likely due to placeholder NAG): %v\n", err)
			outcomeResp.Result = -1
			outcomeResp.Status = "mock_failure_or_timeout"
			outcomeResp.Message = "Mocked outcome due to placeholder error"
			// Ensure BlockID is also mocked if not present
			if outcomeResp.BlockID == "" {
				outcomeResp.BlockID = "mockBlockID_after_outcome_error"
			}
		}
		fmt.Printf("Transaction Outcome: Result %d, Status '%s', BlockID '%s', Message '%s'\n",
			outcomeResp.Result, outcomeResp.Status, outcomeResp.BlockID, outcomeResp.Message)

		// 6. Get Transaction Details
		if outcomeResp.BlockID != "" || (outcomeResp.Status == "confirmed" || outcomeResp.Status == "mock_success") {
			blockIDToUse := outcomeResp.BlockID
			if blockIDToUse == "" { // Should be covered by above but as a safeguard
				blockIDToUse = "mockBlockID_for_example"
				fmt.Println("Using mock BlockID for GetTransaction example.")
			}

			fmt.Printf("Fetching transaction details for BlockID %s, TxID %s...\n", blockIDToUse, txID)
			txDetailsResp, err := account.GetTransaction(blockIDToUse, txID)
			if err != nil {
				log.Printf("Failed to get transaction details (likely due to placeholder NAG): %v\n", err)
				txDetailsResp.Result = -1
				txDetailsResp.Message = "Mocked transaction details due to error"
				txDetailsResp.Transaction.TxID = txID // Ensure TxID is present in mock
				txDetailsResp.Transaction.Data = "Mocked transaction data"
				txDetailsResp.Transaction.Timestamp = utils.GetFormattedUTCTimestamp()
			}
			fmt.Printf("Transaction Details: Result %d, TxID '%s', Data '%s', Timestamp '%s', Message: '%s'\n",
				txDetailsResp.Result, txDetailsResp.Transaction.TxID, txDetailsResp.Transaction.Data, txDetailsResp.Transaction.Timestamp, txDetailsResp.Message)
		} else {
			fmt.Printf("Skipping GetTransaction as BlockID is missing or status is not confirmed/mock_success. Status: '%s', BlockID: '%s'\n", outcomeResp.Status, outcomeResp.BlockID)
		}
	} else {
		fmt.Println("Skipping transaction outcome and details fetching as no TxID was available from submission.")
	}

	// 7. Close Account
	account.Close()
	fmt.Println("Account closed.")
}
</file>

<file path="examples/signing_data/main.go">
package main

import (
	"fmt"
	"log"

	"github.com/circular-protocol/circular-go/circular_protocol_api"
	"github.com/circular-protocol/circular-go/utils"
)

func main() {
	fmt.Println("Circular Go Enterprise API - Data Signing and Certificate Example")
	fmt.Printf("Current UTC Timestamp: %s\n", utils.GetFormattedUTCTimestamp())

	// Example private key (NEVER use real private keys directly in code for production)
	const privateKeyHex = "11842e4034999297038f59f054d1794389758469070e15999837078cec243f55"
	const sampleData = "This is some sample data to be signed."

	// 1. Certificate Object Usage
	cert := &circular_protocol_api.Certificate{}
	cert.SetData(sampleData)
	fmt.Printf("Certificate Data: '%s'\n", cert.GetData())
	fmt.Printf("Certificate Size: %d bytes\n", cert.GetCertificateSize())
	jsonCert, err := cert.GetJSONCertificate()
	if err != nil {
		log.Fatalf("Failed to get JSON certificate: %v", err)
	}
	fmt.Printf("JSON Certificate: %s\n", jsonCert)

	// 2. Data Signing
	// We need an Account object to use its SignData method, even if we're not doing network ops.
	// Alternatively, SignData could be a static utility if it doesn't depend on account state.
	// For now, it's part of Account.
	account := &circular_protocol_api.Account{}
	// No need to Open or SetNetwork if only using SignData and it has no dependencies on those states.
	// However, our current SignData doesn't use Account state, so this is fine.

	fmt.Printf("Original Data: '%s'\n", sampleData)
	signature, err := account.SignData(sampleData, privateKeyHex)
	if err != nil {
		log.Fatalf("Failed to sign data: %v", err)
	}
	fmt.Printf("Data Signature (Hex): %s\n", signature)

	// (Optional) Verify signature - this would require having the public key
	// and using a verification function (e.g., schnorr.Verify with btcec.ParsePubKey)
	// This is out of scope for this example but a good next step for a real crypto util.
	fmt.Println("Data signing example complete.")
}
</file>

<file path=".gitignore">
# If you prefer the allow list template instead of the deny list, see community template:
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
#
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Code coverage profiles and other test artifacts
*.out
coverage.*
*.coverprofile
profile.cov

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work
go.work.sum

# env file
.env

# Editor/IDE
# .idea/
# .vscode/
</file>

<file path="go.mod">
module github.com/circular-protocol/circular-go

go 1.24.3
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Circular Protocol Team

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# Circular Protocol Go Enterprise API

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

Official Circular Protocol Enterprise Go API for data certification on the blockchain.

## Description

This library provides tools for creating and submitting data certificates to the Circular blockchain using the Go language. It includes functionalities for managing accounts, setting network configurations, signing data, and interacting with the Circular Network Access Gateway (NAG).

## Features

-   **Account Management:** Open, update (fetch nonce), and close accounts.
-   **Network Configuration:** Set blockchain network (e.g., "testnet", "mainnet") and chain identifier.
-   **Data Certification:** Create certificate data and submit it to the blockchain via NAG.
-   **Data Signing:** Sign arbitrary data or certificate data using private keys (SECP256k1 with Schnorr signatures).
-   **Transaction Monitoring:** Poll for transaction outcomes and retrieve transaction details from NAG.
-   **Timestamp Generation:** Generate formatted UTC timestamps.

## Installation

To install the Circular Protocol Go Enterprise API package, run the following commands:

```bash
go get github.com/circular-protocol/circular-go
```

Then, ensure your project dependencies are tidy:

```bash
go mod tidy
```

## Usage

Below is an example demonstrating the basic workflow for using the API:

```go
package main

import (
	"fmt"
	"log"
	"strings" // Added for example logic

	"github.com/circular-protocol/circular-go/circular_protocol_api"
	"github.com/circular-protocol/circular-go/utils"
)

func main() {
	fmt.Println("Circular Go Enterprise API Example")
	fmt.Printf("Current UTC Timestamp: %s\n", utils.GetFormattedUTCTimestamp())

	// Replace with your actual address and private key
	const userAddress = "your-wallet-address-hex"
	// IMPORTANT: Never hardcode private keys in production code.
	// This is for demonstration purposes only. Use environment variables or a secure vault.
	const userPrivateKeyHex = "your-private-key-hex" // Example: "11842e4034999297038f59f054d1794389758469070e15999837078cec243f55"
	const blockchainID = "0x8a20baa40c45dc5055aeb26197c203e576ef389d9acb171bd62da11dc5ad72b2" // Example blockchain ID

	account := &circular_protocol_api.Account{}

	// 1. Open Account
	account.Open(userAddress)
	fmt.Printf("Account opened for address: %s\n", account.Address)

	// 2. Set Network and Blockchain
	err := account.SetNetwork("testnet") // Or "mainnet"
	if err != nil {
		log.Fatalf("Failed to set network: %v", err)
	}
	account.SetBlockchain(blockchainID)
	fmt.Printf("Network: %s, NAG URL: %s\n", account.Network, account.NAGURL)
	fmt.Printf("Blockchain ID: %s\n", account.Blockchain)

	// 3. Update Account (Fetch Nonce)
	// In a real scenario, this queries the network for the latest nonce.
	// The current implementation has a placeholder for this HTTP call.
	fmt.Println("Attempting to update account (fetch nonce)...")
	if err := account.UpdateAccount(); err != nil {
		log.Printf("Warning: Failed to update account (fetch nonce): %v. Using default Nonce: %d\n", err, account.Nonce)
	} else {
		fmt.Printf("Account Nonce updated to: %d\n", account.Nonce)
	}

	// 4. Prepare data and submit certificate
	certificateData := fmt.Sprintf("My important data for certification at %s", utils.GetFormattedUTCTimestamp())

	fmt.Printf("Submitting certificate with data: '%s'\n", certificateData)
	submitResp, err := account.SubmitCertificate(certificateData, userPrivateKeyHex)
	if err != nil {
		log.Printf("Failed to submit certificate (likely due to placeholder NAG): %v\n", err)
		// Mock TxID if submission fails to allow example flow to continue
		if submitResp.Response.TxID == "" {
			submitResp.Response.TxID = "mockTxID_for_example_flow_due_to_error"
			fmt.Println("Using mock TxID for example flow as submission failed.")
		}
	}

	if submitResp.Result == 200 || (submitResp.Response.TxID != "" && !strings.HasPrefix(submitResp.Response.TxID, "mockTxID_")) {
		fmt.Printf("Certificate submission potentially successful or pending. Transaction ID: %s\n", submitResp.Response.TxID)
	} else if submitResp.Response.TxID != "" && strings.HasPrefix(submitResp.Response.TxID, "mockTxID_") {
        // This case handles when mock TxID was used due to initial error.
        fmt.Printf("Certificate submission was mocked. Transaction ID: %s\n", submitResp.Response.TxID)
    } else {
		fmt.Printf("Certificate submission failed. Result: %d, Message: %s\n", submitResp.Result, submitResp.Message)
        // If submission truly failed and we don't have a TxID, we can't proceed with below steps.
        // For example's sake, we might still use a mock TxID if none was set.
        if submitResp.Response.TxID == "" {
            submitResp.Response.TxID = "mockTxID_for_failed_submission"
            fmt.Println("Using mock TxID for further example steps after submission failure.")
        }
	}

    // Proceed with outcome and details fetching only if we have a TxID (real or mocked)
    if submitResp.Response.TxID != "" {
        txID := submitResp.Response.TxID

        // 5. Get Transaction Outcome
        fmt.Printf("Polling for transaction outcome for TxID: %s...\n", txID)
        outcomeResp, err := account.GetTransactionOutcome(txID, 15) // Reduced timeout for example
        if err != nil {
            log.Printf("Failed to get transaction outcome (likely due to placeholder NAG): %v\n", err)
            // Mock an outcome if the call fails, for example purposes
            outcomeResp.Result = -1
            outcomeResp.Status = "mock_failure_or_timeout"
            outcomeResp.Message = "Mocked outcome due to placeholder error"
			outcomeResp.BlockID = "" // Ensure BlockID is empty for mock failure
        }
        fmt.Printf("Transaction Outcome: Result %d, Status '%s', BlockID '%s', Message '%s'\n",
            outcomeResp.Result, outcomeResp.Status, outcomeResp.BlockID, outcomeResp.Message)

        // 6. Get Transaction Details (if outcome was notionally successful or has a BlockID)
        // For example, we might try if BlockID is present or if status indicates some success.
        // Here, we'll proceed if a mock or real BlockID is present.
        if outcomeResp.BlockID != "" || (outcomeResp.Status == "confirmed" || outcomeResp.Status == "mock_success") { // Added mock_success for demo
            // If BlockID is empty from a failed/mocked outcome, create a mock BlockID
            blockIDToUse := outcomeResp.BlockID
            if blockIDToUse == "" {
                blockIDToUse = "mockBlockID_for_example"
                fmt.Println("Using mock BlockID for GetTransaction example.")
            }

            fmt.Printf("Fetching transaction details for BlockID %s, TxID %s...\n", blockIDToUse, txID)
            txDetailsResp, err := account.GetTransaction(blockIDToUse, txID)
            if err != nil {
                log.Printf("Failed to get transaction details (likely due to placeholder NAG): %v\n", err)
                // Mock details if call fails
                txDetailsResp.Result = -1
				txDetailsResp.Message = "Mocked transaction details due to error"
                txDetailsResp.Transaction.Data = "Mocked transaction data"
                txDetailsResp.Transaction.Timestamp = utils.GetFormattedUTCTimestamp()
				txDetailsResp.Transaction.TxID = txID
            }
            fmt.Printf("Transaction Details: Result %d, TxID '%s', Data '%s', Timestamp '%s', Message: '%s'\n",
                txDetailsResp.Result, txDetailsResp.Transaction.TxID, txDetailsResp.Transaction.Data, txDetailsResp.Transaction.Timestamp, txDetailsResp.Message)
        } else {
			fmt.Println("Skipping GetTransaction details as BlockID is not available or transaction status is not suitable.")
		}
    } else {
		fmt.Println("Skipping transaction outcome and details fetching as no TxID was available from submission.")
	}


	// 7. Close Account
	account.Close()
	fmt.Println("Account closed.")
}
```

## API Overview

The primary components of this API are:

*   **`circular_protocol_api.Account`**:
    *   Manages account state (address, network, nonce).
    *   Handles interactions with the Circular Network Access Gateway (NAG) for operations like updating account nonce, submitting certificates, and querying transactions.
    *   Provides data signing capabilities.
*   **`circular_protocol_api.Certificate`**:
    *   Represents a data certificate.
    *   Methods to set/get data, get JSON representation, and certificate size.
*   **`utils.GetFormattedUTCTimestamp()`**:
    *   A utility function to generate a UTC timestamp string in the format `YYYY-MM-DDTHH:MM:SSZ`.

**Note on Network Interactions:** The methods involving direct communication with the Circular Network Access Gateway (`UpdateAccount`, `SubmitCertificate`, `GetTransactionOutcome`, `GetTransaction`) currently use placeholder URLs and logic. For actual use, these will need to be configured with the correct NAG API endpoints and request/response structures provided by Circular Protocol. The example above includes mocked responses for these calls to illustrate the intended API flow.

## Contributing

Contributions are welcome! Please fork the repository, make your changes, and submit a pull request.

1.  Fork the Project
2.  Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3.  Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4.  Push to the Branch (`git push origin feature/AmazingFeature`)
5.  Open a Pull Request

## License

Distributed under the MIT License. See `LICENSE` file for more information.
(A `LICENSE` file with the MIT license text should exist in the repository root.)
</file>

<file path="utils/helpers.go">
/*
 * Author: Danny De Novi (dannydenovi29@gmail.com)
 * Date: 12/10/2024
 * License: MIT
 */

package utils

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/sha256"
	"encoding/asn1"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"time"

	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/decred/dcrd/dcrec/secp256k1/v4"
)

/* SendRequest sends an HTTP POST request with JSON data
* @param data interface{} - data to send
* @param nagFunction string - function to call
* @param nagURL string - URL to call
* @return map[string]interface{} - response
* @return error - error
 */
// SendRequest performs an HTTP POST request and handles the JSON response
func SendRequest(data interface{}, nagFunction string, nagURL string) map[string]interface{} {
	url := nagURL + nagFunction

	// Convert the data to JSON
	jsonData, err := json.Marshal(data)
	if err != nil {
		response := map[string]interface{}{
			"Result":   "500",
			"Response": "Wrong JSON format",
		}

		return response
	}

	// Create the request
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		response := map[string]interface{}{
			"Result":   "500",
			"Response": "Error during the creation of the request",
		}

		return response
	}
	req.Header.Set("Content-Type", "application/json")

	// Send the request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		response := map[string]interface{}{
			"Result":   "500",
			"Response": "Error during the sending of the request",
		}

		return response
	}
	defer resp.Body.Close()

	// Read the response and decode it
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		response := map[string]interface{}{
			"Result":   "500",
			"Response": "Error during the reading of the response",
		}

		return response
	}

	if resp.StatusCode != http.StatusOK {
		response := map[string]interface{}{
			"Result":   "500",
			"Response": "Error during the decoding of the response",
		}

		return response
	}

	var response map[string]interface{}
	if err := json.Unmarshal(bodyBytes, &response); err != nil {
		response := map[string]interface{}{
			"Result":   "500",
			"Response": "Error during the decoding of the response",
		}

		return response
	}

	return response
}

// PadNumber pads a number with leading zeros to number less than 10
func PadNumber(number int) string {
	if number < 10 {
		return fmt.Sprintf("0%d", number)
	}
	return fmt.Sprintf("%d", number)
}

// Generate formatted timestamp in the format YYYY-MM-DD-HH:MM:SS
func GetFormattedTimestamp() string {
	t := time.Now()
	return fmt.Sprintf("%d:%s:%s-%s:%s:%s", t.Year(), PadNumber(int(t.Month())), PadNumber(t.Day()), PadNumber(t.Hour()), PadNumber(t.Minute()), PadNumber(t.Second()))
}

// ECSignature defines the structure for DER encoded signature
type ECSignature struct {
	R, S *big.Int
}

/* // SignMessage firma un messaggio con una chiave privata in formato hex e restituisce la firma in formato hex.
* @param message string - message to sign
* @param privateKey string - private key in hex format
* @return string - signature in hex format
 */

func SignMessage(message string, privateKey string) map[string]interface{} {

	bytesPrivateKey, err := hex.DecodeString(privateKey)
	if err != nil {
		return map[string]interface{}{
			"Result":   "500",
			"Response": "Error during the decoding of the private key",
		}
	}

	privKey := secp256k1.PrivKeyFromBytes(bytesPrivateKey)

	messageHash := chainhash.HashB([]byte(message))
	r, s, err := ecdsa.Sign(rand.Reader, privKey.ToECDSA(), messageHash)
	if err != nil {
		return map[string]interface{}{
			"Result":   "500",
			"Response": "Error during the signing of the message",
		}
	}

	derSignature, err := asn1.Marshal(ECDSASignature{R: r, S: s})

	if err != nil {
		return map[string]interface{}{
			"Result":   "500",
			"Response": "Error during the encoding of the signature",
		}
	}

	stringDERSignature := hex.EncodeToString(derSignature)
	return map[string]interface{}{"Signature": stringDERSignature, "R": r, "S": s}
}

type ECDSASignature struct {
	R, S *big.Int
}

// StringToHex converts a string to a hexadecimal string
func StringToHex(str string) string {
	return hex.EncodeToString([]byte(str))
}

// HexToString coneverts a hexadecimal string to a string
func HexToString(hexStr string) (string, error) {
	bytes, err := hex.DecodeString(hexStr)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// HexFix removes the prefix "0x"
func HexFix(word interface{}) string {
	switch v := word.(type) {
	case int:
		return fmt.Sprintf("%x", v)
	case string:
		if len(v) >= 2 && v[:2] == "0x" {
			return v[2:]
		}
		return v
	default:
		return ""
	}
}

// Sha256 calculates the SHA-256 hash of a string
func Sha256(data string) string {
	hash := sha256.Sum256([]byte(data))
	return hex.EncodeToString(hash[:])
}

func bytesToHex(b []byte) string {
	return hex.EncodeToString(b)
}

// func VerifySignature(publicKey string, message string, signature string) bool {
// 	if len(publicKey) != 130 {
// 		fmt.Println("Invalid public key length")
// 		return false
// 	}

// 	// Remove the 0x prefix from the public key
// 	remove0x := HexFix(publicKey)

// 	// Hash the message to verify with SHA256
// 	msgHash := sha256.Sum256([]byte(message))

// 	// Decode the public key from hex
// 	publicKeyBytes, err := hex.DecodeString(remove0x)
// 	if err != nil {
// 		fmt.Println(err)
// 		return false
// 	}

// 	// Parse the public key
// 	pubKey, err := secp256k1.ParsePubKey(publicKeyBytes)
// 	if err != nil {
// 		fmt.Println(err)
// 		return false
// 	}

// 	// Convert btcec.PublicKey to ecdsa.PublicKey
// 	ecdsaPubKey := ecdsa.PublicKey{
// 		Curve: secp256k1.S256(),
// 		X:     pubKey.X(),
// 		Y:     pubKey.Y(),
// 	}

// 	// Decode the signature from hex
// 	signatureBytes, err := hex.DecodeString(signature)
// 	if err != nil {
// 		fmt.Println(err)
// 		return false
// 	}

// 	// Parse the signature from DER format
// 	var ecsig ECDSASignature
// 	_, err = asn1.Unmarshal(signatureBytes, &ecsig)
// 	if err != nil {
// 		fmt.Println(err)
// 		return false
// 	}

// 	// Verify the signature
// 	return ecdsa.Verify(&ecdsaPubKey, msgHash[:], ecsig.R, ecsig.S)
// }

// func GetPublicKey(privateKey string) string {
// 	privKeyBytes, err := hex.DecodeString(privateKey)
// 	if err != nil {
// 		return ""
// 	}

// 	privKey := secp256k1.PrivKeyFromBytes(privKeyBytes)
// 	pubKey := privKey.PubKey()

// 	return hex.EncodeToString(pubKey.SerializeUncompressed())
// }

// func GetKeysFromString(seedPhrase string) (map[string]string, error) {
// 	// Generate private key using RFC 6979
// 	hashHex := Sha256(seedPhrase)
// 	hash, err := hex.DecodeString(hashHex)
// 	if err != nil {
// 		return nil, err
// 	}

// 	privateKey := secp256k1.PrivKeyFromBytes(hash)
// 	publicKey := privateKey.PubKey()

// 	// Encode private key in DER format
// 	privateKeyDER := privateKey.Serialize()

// 	// Encode public key in DER format
// 	publicKeyDER := publicKey.SerializeUncompressed()

// 	// Generate address from public key
// 	addressDER := Sha256(bytesToHex(publicKey.SerializeUncompressed()))

// 	// Create a map to hold the results
// 	result := map[string]string{
// 		"privateKey": bytesToHex(privateKeyDER),
// 		"publicKey":  bytesToHex(publicKeyDER),
// 		"address":    addressDER,
// 		"seedPhrase": seedPhrase,
// 	}

// 	return result, nil
// }

// NAG FUNCTIONS

const TEST_CONTRACT = "Circular_TestContract_"
const CALL_CONTRACT = "Circular_CallContract_"
const CHECK_WALLET = "Circular_CheckWallet_"
const GET_WALLET = "Circular_GetWallet_"
const GET_LATEST_TRANSACTIONS = "Circular_GetLatestTransactions_"
const GET_WALLET_BALANCE = "Circular_GetWalletBalance_"
const REGISTER_WALLET = "Circular_RegisterWallet_"
const GET_DOMAIN = "Circular_GetDomain_"
const GET_ASSET_LIST = "Circular_GetAssetList_"
const GET_ASSET = "Circular_GetAsset_"
const GET_ASSET_SUPPLY = "Circular_GetAssetSupply_"
const GET_VOUCHER = "Circular_GetVoucher_"
const GET_BLOCK_RANGE = "Circular_GetBlockRange_"
const GET_BLOCK = "Circular_GetBlock_"
const GET_BLOCK_COUNT = "Circular_GetBlockCount_"
const GET_ANALYTICS = "Circular_GetAnalytics_"
const GET_BLOCKCHAINS = "Circular_GetBlockchains_"
const GET_PENDING_TRANSACTION = "Circular_GetPendingTransaction_"
const GET_TRANSACTION_BY_ID = "Circular_GetTransactionbyID_"
const GET_TRANSACTION_BY_NODE = "Circular_GetTransactionbyNode_"
const GET_TRANSACTIONS_BY_ADDRESS = "Circular_GetTransactionbyAddress_"
const GET_TRANSACTION_BY_DATE = "Circular_GetTransactionbyDate_"
const SEND_TRANSACTION = "Circular_AddTransaction_"
const GET_WALLET_NONCE = "Circular_GetWalletNonce_"
</file>

<file path="circular_protocol_api/certificate.go">
package circular_protocol_enterprise_api

import (
	"encoding/hex"
	"encoding/json"
)

// A shared constant from the library details
const libVersion = "1.0.13"

// CCertificate mirrors the C_CERTIFICATE class from the Node.js library.
// It holds the data for a certificate.
type CCertificate struct {
	// Note the use of json tags. This controls how the struct is serialized
	// into JSON, matching the JavaScript object keys exactly.
	Data          string `json:"data"`
	PreviousTxID  string `json:"previousTxID"`
	PreviousBlock string `json:"previousBlock"`
	CodeVersion   string `json:"version"`
}

// NewCCertificate acts as a constructor for a CCertificate instance.
// It initializes the certificate with default values.
func NewCCertificate() *CCertificate {
	return &CCertificate{
		// In Go, string fields are automatically initialized to "" (empty string),
		// which is equivalent to 'null' for these fields in the JS constructor.
		// So we only need to set the version.
		CodeVersion: libVersion,
	}
}

// SetData encodes the provided string into hex and stores it in the certificate.
// The receiver (c *CCertificate) is a pointer, allowing the method to modify the original struct.
func (c *CCertificate) SetData(data string) {
	c.Data = hex.EncodeToString([]byte(data))
}

// GetData decodes the hex data from the certificate back into a string.
// The receiver (c *CCertificate) can be a value receiver here, but pointer is
// conventional for consistency. It returns the decoded string and any potential error.
func (c *CCertificate) GetData() (string, error) {
	// The hexToString helper would handle decoding
	return hexToString(c.Data)
}

// GetJSONCertificate serializes the certificate struct into a JSON formatted string.
// It returns the JSON string and any potential error from the marshalling process.
func (c *CCertificate) GetJSONCertificate() (string, error) {
	// We are marshalling the struct 'c' itself. The json tags on the struct
	// fields will ensure the output keys ("data", "previousTxID", etc.) are correct.
	jsonBytes, err := json.Marshal(c)
	if err != nil {
		return "", err
	}
	return string(jsonBytes), nil
}

// GetCertificateSize calculates the byte size of the JSON-serialized certificate.
// This correctly handles multi-byte characters, just like the Node.js FIX.
func (c *CCertificate) GetCertificateSize() (int, error) {
	// By marshalling to JSON first, we get the exact representation whose
	// size we need to measure. The length of the resulting byte slice is the size.
	jsonBytes, err := json.Marshal(c)
	if err != nil {
		return 0, err
	}
	return len(jsonBytes), nil
}

// hexToString is a helper function to decode a hex string.
// It assumes the hex string may or may not have a "0x" prefix.
func hexToString(h string) (string, error) {
	// Trim the "0x" prefix if it exists
	cleanHex := h
	if len(h) > 2 && h[:2] == "0x" {
		cleanHex = h[2:]
	}

	decodedBytes, err := hex.DecodeString(cleanHex)
	if err != nil {
		return "", err
	}
	return string(decodedBytes), nil
}


// // Certificate holds the data for a data certificate.
// type Certificate struct {
// 	Data string `json:"data"` // Data content of the certificate
// }

// // SetData sets the data content of the certificate.
// func (c *Certificate) SetData(data string) {
// 	c.Data = data
// }

// // GetData retrieves the data content of the certificate.
// func (c *Certificate) GetData() string {
// 	return c.Data
// }

// // GetJSONCertificate returns the certificate as a JSON string.
// func (c *Certificate) GetJSONCertificate() (string, error) {
// 	jsonData, err := json.Marshal(c)
// 	if err != nil {
// 		return "", err
// 	}
// 	return string(jsonData), nil
// }

// // GetCertificateSize returns the size of the certificate data in bytes.
// func (c *Certificate) GetCertificateSize() int {
// 	return len([]byte(c.Data))
// }
</file>

<file path="circular_protocol_api/account.go">
package circular_protocol_enterprise_api

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/btcsuite/btcd/btcec/v2"
	"github.com/btcsuite/btcd/btcec/v2/schnorr"
	"github.com/btcsuite/btcd/btcec"
)

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

)

const (
	libVersion   = "1.0.1"
	networkURL   = "https://circularlabs.io/network/getNAG?network="
	defaultChain = "0x8a20baa40c45dc5055aeb26197c203e576ef389d9acb171bd62da11dc5ad72b2"
	defaultNAG   = "https://nag.circularlabs.io/NAG.php?cep="
)

// CEPAccount mirrors the structure and functionality of the CEP_Account class in Node.js.
type CEPAccount struct {
	Address      string
	PublicKey    string
	Info         string
	CodeVersion  string
	LastError    string
	NAGURL       string
	NetworkNode  string
	Blockchain   string
	LatestTxID   string
	Nonce        int
	Data         map[string]interface{}
	IntervalSec  int
}

// NewCEPAccount creates and initializes a new CEPAccount.
func NewCEPAccount() *CEPAccount {
	return &CEPAccount{
		CodeVersion: libVersion,
		NAGURL:      defaultNAG,
		Blockchain:  defaultChain,
		Data:        make(map[string]interface{}),
		IntervalSec: 2,
	}
}

// Open an account by setting the address.
func (a *CEPAccount) Open(address string) error {
	if address == "" {
		return errors.New("invalid address format")
	}
	a.Address = address
	return nil
}

// UpdateAccount fetches the latest nonce for the account from the network.
func (a *CEPAccount) UpdateAccount() (bool, error) {
	if a.Address == "" {
		return false, errors.New("account is not open")
	}

	data := map[string]string{
		"Blockchain": hexFix(a.Blockchain),
		"Address":    hexFix(a.Address),
		"Version":    a.CodeVersion,
	}

	jsonData, err := json.Marshal(data)
	if err != nil {
		return false, err
	}

	resp, err := http.Post(a.NAGURL+"Circular_GetWalletNonce_"+a.NetworkNode, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return false, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return false, fmt.Errorf("HTTP error! status: %d", resp.StatusCode)
	}

	var jsonResponse map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&jsonResponse); err != nil {
		return false, err
	}

	if result, ok := jsonResponse["Result"].(float64); ok && result == 200 {
		if response, ok := jsonResponse["Response"].(map[string]interface{}); ok {
			if nonce, ok := response["Nonce"].(float64); ok {
				a.Nonce = int(nonce) + 1
				return true, nil
			}
		}
	}

	return false, errors.New("invalid response format or missing Nonce field")
}

// SetNetwork configures the network by fetching the NAG URL.
func (a *CEPAccount) SetNetwork(network string) error {
	resp, err := http.Get(networkURL + network)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("HTTP error! status: %d", resp.StatusCode)
	}

	var data map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return err
	}

	if status, ok := data["status"].(string); ok && status == "success" {
		if url, ok := data["url"].(string); ok {
			a.NAGURL = url
			return nil
		}
	}

	if message, ok := data["message"].(string); ok {
		return errors.New(message)
	}

	return errors.New("failed to get URL")
}

// SetBlockchain sets the blockchain for the account.
func (a *CEPAccount) SetBlockchain(chain string) {
	a.Blockchain = chain
}

// Close resets the account to its default state.
func (a *CEPAccount) Close() {
	a.Address = ""
	a.PublicKey = ""
	a.Info = ""
	a.LastError = ""
	a.NAGURL = defaultNAG
	a.NetworkNode = ""
	a.Blockchain = defaultChain
	a.LatestTxID = ""
	a.Nonce = 0
	a.Data = make(map[string]interface{})
	a.IntervalSec = 2
}

// SignData signs the given data with the provided private key.
func (a *CEPAccount) SignData(data, privateKey string) (string, error) {
	if a.Address == "" {
		return "", errors.New("account is not open")
	}

	privKeyBytes, err := hex.DecodeString(hexFix(privateKey))
	if err != nil {
		return "", err
	}

	privKey, _ := btcec.PrivKeyFromBytes(btcec.S256(), privKeyBytes)

	hasher := sha256.New()
	hasher.Write([]byte(data))
	msgHash := hasher.Sum(nil)

	signature, err := privKey.Sign(msgHash)
	if err != nil {
		return "", err
	}

	return hex.EncodeToString(signature.Serialize()), nil
}

// GetTransactionByID retrieves a transaction by its ID within a block range.
func (a *CEPAccount) GetTransactionbyID(txID string, start, end int) (map[string]interface{}, error) {
	data := map[string]string{
		"Blockchain": hexFix(a.Blockchain),
		"ID":         hexFix(txID),
		"Start":      strconv.Itoa(start),
		"End":        strconv.Itoa(end),
		"Version":    a.CodeVersion,
	}

	jsonData, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}

	resp, err := http.Post(a.NAGURL+"Circular_GetTransactionbyID_"+a.NetworkNode, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, errors.New("network response was not ok")
	}

	var jsonResponse map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&jsonResponse); err != nil {
		return nil, err
	}

	return jsonResponse, nil
}

// SubmitCertificate creates and submits a certificate to the blockchain.
func (a *CEPAccount) SubmitCertificate(pdata, privateKey string) (map[string]interface{}, error) {
	if a.Address == "" {
		return nil, errors.New("account is not open")
	}

	payloadObject := map[string]string{
		"Action": "CP_CERTIFICATE",
		"Data":   stringToHex(pdata),
	}
	jsonStr, err := json.Marshal(payloadObject)
	if err != nil {
		return nil, err
	}
	payload := stringToHex(string(jsonStr))

	timestamp := getFormattedTimestamp()
	str := hexFix(a.Blockchain) + hexFix(a.Address) + hexFix(a.Address) + payload + strconv.Itoa(a.Nonce) + timestamp
	hasher := sha256.New()
	hasher.Write([]byte(str))
	id := hex.EncodeToString(hasher.Sum(nil))

	signature, err := a.SignData(id, privateKey)
	if err != nil {
		return nil, err
	}

	data := map[string]string{
		"ID":         id,
		"From":       hexFix(a.Address),
		"To":         hexFix(a.Address),
		"Timestamp":  timestamp,
		"Payload":    payload,
		"Nonce":      strconv.Itoa(a.Nonce),
		"Signature":  signature,
		"Blockchain": hexFix(a.Blockchain),
		"Type":       "C_TYPE_CERTIFICATE",
		"Version":    a.CodeVersion,
	}

	jsonData, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}

	resp, err := http.Post(a.NAGURL+"Circular_AddTransaction_"+a.NetworkNode, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, errors.New("network response was not ok")
	}

	var jsonResponse map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&jsonResponse); err != nil {
		return nil, err
	}

	return jsonResponse, nil
}

// GetTransactionOutcome polls for the result of a transaction.
func (a *CEPAccount) GetTransactionOutcome(txID string, timeoutSec int) (map[string]interface{}, error) {
	timeout := time.After(time.Duration(timeoutSec) * time.Second)
	ticker := time.NewTicker(time.Duration(a.IntervalSec) * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-timeout:
			return nil, errors.New("timeout exceeded")
		case <-ticker.C:
			data, err := a.GetTransactionbyID(txID, 0, 10)
			if err != nil {
				return nil, err
			}

			if result, ok := data["Result"].(float64); ok && result == 200 {
				if response, ok := data["Response"].(map[string]interface{}); ok {
					if status, ok := response["Status"].(string); ok && status != "Pending" {
						return response, nil
					}
				}
			}
		}
	}
}

// Helper functions corresponding to the Node.js implementation.

func padNumber(num int) string {
	if num < 10 {
		return "0" + strconv.Itoa(num)
	}
	return strconv.Itoa(num)
}

func getFormattedTimestamp() string {
	date := time.Now().UTC()
	return fmt.Sprintf("%d:%s:%s-%s:%s:%s",
		date.Year(),
		padNumber(int(date.Month())),
		padNumber(date.Day()),
		padNumber(date.Hour()),
		padNumber(date.Minute()),
		padNumber(date.Second()))
}

func hexFix(word string) string {
	return strings.TrimPrefix(word, "0x")
}

func stringToHex(s string) string {
	return hex.EncodeToString([]byte(s))
}

func hexToString(s string) (string, error) {
	b, err := hex.DecodeString(hexFix(s))
	if err != nil {
		return "", err
	}
	return string(b), nil
}

// // SubmitResponse is the expected response structure after submitting a certificate.
// type SubmitResponse struct {
// 	Result   int    `json:"result"`
// 	Message  string `json:"message,omitempty"`
// 	Response struct {
// 		TxID string `json:"TxID,omitempty"`
// 	} `json:"response,omitempty"`
// }

// // TransactionOutcomeResponse is the expected response for a transaction outcome query.
// type TransactionOutcomeResponse struct {
// 	Result  int    `json:"result"`
// 	Message string `json:"message,omitempty"`
// 	BlockID string `json:"BlockID,omitempty"` // Or any other fields NAG returns
// 	Status  string `json:"status,omitempty"`  // e.g., "confirmed", "pending", "failed"
// }

// // TransactionResponse is the expected response when fetching a specific transaction.
// type TransactionResponse struct {
// 	Result      int    `json:"result"`
// 	Message     string `json:"message,omitempty"`
// 	Transaction struct {
// 		TxID      string `json:"txID"`
// 		Data      string `json:"data"` // Example field
// 		Timestamp string `json:"timestamp"`
// 		// Add other relevant transaction fields
// 	} `json:"transaction,omitempty"`
// }

// // NetworkConfig holds URLs for a specific network.
// type NetworkConfig struct {
// 	NAGURL         string
// 	NetworkNodeURL string
// }

// // Define network configurations
// var networkMap = map[string]NetworkConfig{
// 	"testnet": {
// 		NAGURL:         "https://nag-testnet.circular.io/v1", // Placeholder
// 		NetworkNodeURL: "https://node-testnet.circular.io",   // Placeholder
// 	},
// 	"mainnet": {
// 		NAGURL:         "https://nag-mainnet.circular.io/v1", // Placeholder
// 		NetworkNodeURL: "https://node-mainnet.circular.io",   // Placeholder
// 	},
// }

// // Account manages interactions with the Circular Protocol for a specific account.
// type Account struct {
// 	Address        string
// 	Network        string // e.g., "testnet", "mainnet"
// 	Blockchain     string // Blockchain identifier
// 	Nonce          int64  // Account nonce, should be int64 for safety
// 	NAGURL         string // Network Access Gateway URL
// 	NetworkNodeURL string // Network Node URL for things like nonce fetching
// 	Client         *http.Client
// }

// // Open initializes a new account with the given address.
// // It also initializes an HTTP client for the account.
// func (a *Account) Open(address string) {
// 	a.Address = address
// 	a.Client = &http.Client{Timeout: 30 * time.Second} // Default timeout
// 	fmt.Println("Account opened for address:", address)
// }

// // SetNetwork sets the blockchain network (e.g., "testnet", "mainnet")
// // and updates NAGURL and NetworkNodeURL accordingly.
// func (a *Account) SetNetwork(networkName string) error {
// 	config, ok := networkMap[strings.ToLower(networkName)]
// 	if !ok {
// 		return fmt.Errorf("unknown network: %s", networkName)
// 	}
// 	a.Network = networkName
// 	a.NAGURL = config.NAGURL
// 	a.NetworkNodeURL = config.NetworkNodeURL
// 	fmt.Printf("Network set to: %s (NAG: %s, Node: %s)\n", networkName, a.NAGURL, a.NetworkNodeURL)
// 	return nil
// }

// // SetBlockchain sets the blockchain identifier for the account.
// func (a *Account) SetBlockchain(chain string) {
// 	a.Blockchain = chain
// 	fmt.Println("Blockchain set to:", chain)
// }

// // UpdateAccount fetches the latest Nonce for the account from the network node.
// // This is a simplified version. The actual endpoint and response structure
// // for fetching nonce need to be defined based on NAG/Node API.
// func (a *Account) UpdateAccount() error {
// 	if a.Address == "" || a.NetworkNodeURL == "" {
// 		return fmt.Errorf("address or network node URL not set")
// 	}
// 	// Example: GET <NetworkNodeURL>/accounts/<address>/nonce
// 	// The actual endpoint and response structure will depend on the Circular API.
// 	// For now, let's assume a placeholder endpoint and response.
// 	reqURL := fmt.Sprintf("%s/accounts/%s/nonce", a.NetworkNodeURL, a.Address)
// 	resp, err := a.Client.Get(reqURL)
// 	if err != nil {
// 		return fmt.Errorf("failed to fetch nonce: %w", err)
// 	}
// 	defer resp.Body.Close()

// 	if resp.StatusCode != http.StatusOK {
// 		return fmt.Errorf("failed to fetch nonce: received status code %d", resp.StatusCode)
// 	}

// 	var nonceResp struct {
// 		Nonce int64 `json:"nonce"`
// 	}
// 	if err := json.NewDecoder(resp.Body).Decode(&nonceResp); err != nil {
// 		return fmt.Errorf("failed to decode nonce response: %w", err)
// 	}
// 	a.Nonce = nonceResp.Nonce
// 	fmt.Println("Account Nonce updated to:", a.Nonce)
// 	return nil
// }

// // SignData signs the provided data string using the given private key hex string.
// // It returns the signature as a hex string.
// // This uses SECP256k1, common in many blockchains.
// func (a *Account) SignData(data string, privateKeyHex string) (string, error) {
// 	privKeyBytes, err := hex.DecodeString(privateKeyHex)
// 	if err != nil {
// 		return "", fmt.Errorf("failed to decode private key: %w", err)
// 	}
// 	privKey, _ := btcec.PrivKeyFromBytes(privKeyBytes)

// 	// Hash the data before signing (standard practice)
// 	hashedData := sha256.Sum256([]byte(data))

// 	// Sign using Schnorr signatures (often used with SECP256k1)
// 	// If ECDSA is required: signature, err := ecdsa.SignASN1(rand.Reader, privKey.ToECDSA(), hashedData[:])
// 	signature, err := schnorr.Sign(privKey, hashedData[:])
// 	if err != nil {
// 		return "", fmt.Errorf("failed to sign data: %w", err)
// 	}

// 	return hex.EncodeToString(signature.Serialize()), nil
// }

// // SubmitCertificate creates a certificate from data, signs it, and submits it.
// // This is a simplified version. The actual request payload for NAG needs to be defined.
// func (a *Account) SubmitCertificate(data string, privateKeyHex string) (SubmitResponse, error) {
// 	var response SubmitResponse
// 	if a.Address == "" || a.NAGURL == "" {
// 		response.Result = -1
// 		response.Message = "account address or NAG URL not set"
// 		return response, fmt.Errorf(response.Message)
// 	}

// 	// 1. Create certificate (using the Certificate struct from certificate.go)
// 	cert := Certificate{Data: data}
// 	// In a real scenario, you might structure the data to be signed more carefully,
// 	// possibly including nonce, address, etc. For now, just signing the raw data.
// 	// jsonCert, _ := cert.GetJSONCertificate() // Or some other canonical representation

// 	// 2. Sign the data
// 	// The data to be signed might need to be a specific format including nonce, etc.
// 	// For this example, we'll just sign the raw data string.
// 	// A more robust implementation would construct a specific message to sign.
// 	signature, err := a.SignData(data, privateKeyHex) // Or sign(jsonCert, ...)
// 	if err != nil {
// 		response.Result = -1
// 		response.Message = fmt.Sprintf("failed to sign data: %v", err)
// 		return response, err
// 	}

// 	// 3. Construct payload for NAG
// 	// This is a placeholder. The actual payload structure depends on the NAG API.
// 	payload := map[string]interface{}{
// 		"address":     a.Address,
// 		"blockchain":  a.Blockchain,
// 		"nonce":       a.Nonce,
// 		"certificate": cert.Data, // Or perhaps the JSON representation
// 		"signature":   signature,
// 	}
// 	jsonPayload, err := json.Marshal(payload)
// 	if err != nil {
// 		response.Result = -1
// 		response.Message = fmt.Sprintf("failed to marshal payload: %v", err)
// 		return response, err
// 	}

// 	// 4. Submit to NAG
// 	reqURL := fmt.Sprintf("%s/submit_certificate", a.NAGURL) // Placeholder endpoint
// 	req, err := http.NewRequest("POST", reqURL, bytes.NewBuffer(jsonPayload))
// 	if err != nil {
// 		response.Result = -1
// 		response.Message = fmt.Sprintf("failed to create request: %v", err)
// 		return response, err
// 	}
// 	req.Header.Set("Content-Type", "application/json")

// 	resp, err := a.Client.Do(req)
// 	if err != nil {
// 		response.Result = -1
// 		response.Message = fmt.Sprintf("failed to submit certificate: %v", err)
// 		return response, err
// 	}
// 	defer resp.Body.Close()

// 	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
// 		// Try to read body for more info if JSON decoding fails
// 		// bodyBytes, _ := io.ReadAll(resp.Body)
// 		// return SubmitResponse{Result: resp.StatusCode, Message: "failed to decode response: " + string(bodyBytes)}, err
// 		return SubmitResponse{Result: resp.StatusCode, Message: "failed to decode response body"}, fmt.Errorf("failed to decode submit response: %w", err)
// 	}

// 	if response.Result == 200 || (resp.StatusCode >= 200 && resp.StatusCode < 300) {
// 		a.Nonce++ // Increment nonce on successful submission
// 		fmt.Println("Certificate submitted. New Nonce:", a.Nonce)
// 	} else if response.Message == "" {
// 		response.Message = fmt.Sprintf("NAG returned non-success status: %d", resp.StatusCode)
// 	}
// 	return response, nil
// }

// // GetTransactionOutcome polls for the outcome of a transaction.
// // This is a simplified version. Endpoint and polling logic might be more complex.
// func (a *Account) GetTransactionOutcome(txID string, timeoutSec int) (TransactionOutcomeResponse, error) {
// 	var response TransactionOutcomeResponse
// 	if a.NAGURL == "" {
// 		response.Result = -1
// 		response.Message = "NAG URL not set"
// 		return response, fmt.Errorf(response.Message)
// 	}

// 	startTime := time.Now()
// 	endpoint := fmt.Sprintf("%s/transactions/%s/outcome", a.NAGURL, txID) // Placeholder

// 	for {
// 		if time.Since(startTime).Seconds() > float64(timeoutSec) {
// 			response.Result = -1
// 			response.Message = "timeout waiting for transaction outcome"
// 			return response, fmt.Errorf(response.Message)
// 		}

// 		req, err := http.NewRequest("GET", endpoint, nil)
// 		if err != nil {
// 			response.Result = -1
// 			response.Message = "failed to create request"
// 			return response, err
// 		}

// 		httpResp, err := a.Client.Do(req)
// 		if err != nil {
// 			// Network error, wait and retry
// 			time.Sleep(5 * time.Second) // Wait 5 seconds before retrying
// 			continue
// 		}

// 		err = json.NewDecoder(httpResp.Body).Decode(&response)
// 		httpResp.Body.Close() // Close body promptly

// 		if err != nil {
// 			// Error decoding, maybe NAG is down or format changed
// 			response.Result = httpResp.StatusCode
// 			response.Message = "failed to decode transaction outcome response"
// 			return response, fmt.Errorf("%s: %w", response.Message, err)
// 		}

// 		// Assuming a "status" field indicates completion (e.g., "confirmed", "failed")
// 		// or result indicates finality. This logic depends on NAG API.
// 		if response.Result == 200 && (response.Status == "confirmed" || response.Status == "failed") {
// 			fmt.Printf("Transaction outcome received for %s: %s\n", txID, response.Status)
// 			return response, nil
// 		}
// 		if response.Result != 200 && response.Result != 0 && response.Result != http.StatusProcessing && response.Result != http.StatusAccepted {
// 			// If NAG indicates an error other than "still processing"
// 			return response, fmt.Errorf("NAG error fetching outcome: %s (status: %d)", response.Message, response.Result)
// 		}

// 		time.Sleep(5 * time.Second) // Polling interval
// 	}
// }

// // GetTransaction retrieves details of a specific transaction.
// // This is a simplified version. Endpoint and response structure depend on NAG API.
// func (a *Account) GetTransaction(blockID string, txID string) (TransactionResponse, error) {
// 	var response TransactionResponse
// 	if a.NAGURL == "" {
// 		response.Result = -1
// 		response.Message = "NAG URL not set"
// 		return response, fmt.Errorf(response.Message)
// 	}

// 	// Example: NAGURL/transactions/<blockID>/<txID> - This is a guess
// 	endpoint := fmt.Sprintf("%s/transactions/%s/%s", a.NAGURL, blockID, txID) // Placeholder
// 	req, err := http.NewRequest("GET", endpoint, nil)
// 	if err != nil {
// 		response.Result = -1
// 		response.Message = "failed to create request"
// 		return response, err
// 	}

// 	httpResp, err := a.Client.Do(req)
// 	if err != nil {
// 		response.Result = -1
// 		response.Message = "failed to get transaction"
// 		return response, err
// 	}
// 	defer httpResp.Body.Close()

// 	if err := json.NewDecoder(httpResp.Body).Decode(&response); err != nil {
// 		response.Result = httpResp.StatusCode
// 		response.Message = "failed to decode transaction response"
// 		return response, fmt.Errorf("%s: %w", response.Message, err)
// 	}

// 	if response.Result != 200 && response.Message == "" {
// 		response.Message = fmt.Sprintf("NAG returned non-success status: %d for GetTransaction", httpResp.StatusCode)
// 	}
// 	return response, nil
// }

// // Close resets the account fields.
// func (a *Account) Close() {
// 	a.Address = ""
// 	a.Network = ""
// 	a.Blockchain = ""
// 	a.Nonce = 0
// 	a.NAGURL = ""
// 	a.NetworkNodeURL = ""
// 	a.Client = nil // Release the client
// 	fmt.Println("Account closed and reset.")
// }
</file>

</files>
